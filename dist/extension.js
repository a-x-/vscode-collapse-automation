"use strict";const i=require("vscode"),{parse:k}=require("@typescript-eslint/typescript-estree");let e,v=null,y=!1;const T=new Map;function N(r,g){const C=[];try{let f=function(n){if(!(!n||typeof n!="object")){if(n.type==="CallExpression"&&n.callee&&n.loc&&n.callee.type==="MemberExpression"&&n.callee.object&&n.callee.property)for(const s of g){if(!s.includes("."))continue;const[a,L]=s.split(".");if(n.callee.object.type==="Identifier"&&n.callee.object.name===a&&n.callee.property.type==="Identifier"&&n.callee.property.name===L){const d=n.loc.start.line-1,$=n.loc.end.line-1;d!==$&&C.push({pattern:s,startLine:d,endLine:$})}}for(const s in n)if(s!=="parent"&&n[s])if(Array.isArray(n[s]))for(const a of n[s])f(a);else typeof n[s]=="object"&&f(n[s])}};const p=k(r,{ecmaVersion:"latest",sourceType:"module",jsx:!0,errorOnUnknownASTType:!1,range:!0,loc:!0});f(p)}catch(p){e.appendLine(`- ERROR parsing document for AST: ${p.message}`)}return C}function D(r){e=i.window.createOutputChannel("Collapse Automation"),e.appendLine('Extension "collapse-automation" is now active.');const g=a=>{a&&(v&&clearTimeout(v),v=setTimeout(()=>{E(a)},500))},C=i.workspace.onDidChangeTextDocument(a=>{y||g(a.document)}),p=i.workspace.onDidOpenTextDocument(a=>{E(a)}),f=i.window.onDidChangeActiveTextEditor(a=>{a&&E(a.document)}),n=i.window.onDidChangeTextEditorVisibleRanges(a=>{if(y)return;const d=a.textEditor.document,$=d.uri.toString();if(!["javascript","javascriptreact","typescript","typescriptreact"].includes(d.languageId))return;T.has($)||T.set($,new Set);const c=T.get($),x=c.size,l=N(d.getText(),i.workspace.getConfiguration("collapse-automation").get("alwaysFold",[]));for(const t of l)if(t.endLine>t.startLine){const m=t.startLine+1,w=a.visibleRanges.some(u=>u.start.line<=m&&u.end.line>=m);if(w&&!c.has(t.startLine)){c.add(t.startLine);const u=d.lineAt(t.startLine).text.trim();e.appendLine(`- User manually unfolded ${t.pattern} at line ${t.startLine+1}: ${u.substring(0,50)}...`)}else if(!w&&c.has(t.startLine)){c.delete(t.startLine);const u=d.lineAt(t.startLine).text.trim();e.appendLine(`- User manually folded back ${t.pattern} at line ${t.startLine+1}: ${u.substring(0,50)}...`)}}c.size!==x&&e.appendLine(`- Total manually unfolded functions: ${c.size}`)}),s=i.commands.registerCommand("collapse-automation.activate",()=>{i.window.activeTextEditor?(v&&clearTimeout(v),E(i.window.activeTextEditor.document,!0)):i.window.showInformationMessage("No active editor found")});r.subscriptions.push(C,p,f,n,s),i.window.activeTextEditor&&g(i.window.activeTextEditor.document)}async function E(r,g=!1){if(r.uri.scheme==="output"||r.uri.fsPath.includes("extension-output")||r.uri.fsPath.includes("Collapse Automation")||!["javascript","javascriptreact","typescript","typescriptreact"].includes(r.languageId))return;const p=i.window.activeTextEditor;if(!p||p.document!==r){e.appendLine("- No active editor for this document, skipping");return}const f=p.selections.map(l=>new i.Selection(l.anchor,l.active));g&&(T.delete(r.uri.toString()),e.appendLine("- Manual command: cleared manually unfolded list")),e.appendLine(`
=== ANALYZE START at ${new Date().toISOString()} ===`),e.appendLine(`Document: ${r.uri.fsPath}`),e.appendLine(`isProcessing was: ${y}`),y=!0,e.appendLine(`isProcessing now: ${y}`);const n=i.workspace.getConfiguration("collapse-automation"),s=n.get("alwaysFold",[]),a=n.get("neverFold",[]),L=n.get("collapseLevel",1),d=n.get("enableCollapsePragma",!0);if(e.appendLine(`- Config: alwaysFold: [${s.join(", ")}] (length: ${s.length})`),e.appendLine(`- Config: neverFold: [${a.join(", ")}] (length: ${a.length})`),e.appendLine(`- Config: collapseLevel: ${L}`),e.appendLine(`- Config: enableCollapsePragma: ${d}`),(!d||s.length===0)&&s.length===0){e.appendLine("- SKIPPING: No active folding rules (alwaysFold is empty and pragma disabled)"),y=!1,e.appendLine(`=== ANALYZE END (skipped) ===
`);return}const c=r.getText().split(`
`);e.appendLine(`- Document has ${c.length} lines`);const x=d&&c.some(l=>l.includes("// @collapse"));if(e.appendLine(`- Has @collapse pragma: ${x}`),x){e.appendLine("- ACTION: Found '@collapse' pragma. Will apply folding rules."),e.appendLine("- EXECUTING: editor.foldAll"),await i.commands.executeCommand("editor.foldAll"),e.appendLine("- COMPLETED: editor.foldAll"),L>0&&(e.appendLine(`- EXECUTING: editor.unfoldLevel${L}`),await i.commands.executeCommand(`editor.unfoldLevel${L}`),e.appendLine(`- COMPLETED: editor.unfoldLevel${L}`));const l=[];if(a.length>0){e.appendLine("- Checking neverFold patterns...");for(let t=0;t<c.length;t++){const m=c[t];for(const w of a)try{if(new RegExp(w).test(m)){e.appendLine(`  - Line ${t+1} matches neverFold pattern '${w}': ${m.substring(0,50)}...`),l.push(new i.Position(t,0));break}}catch(u){e.appendLine(`  - ERROR: Invalid regex pattern '${w}': ${u.message}`)}}}l.length>0&&(e.appendLine(`- EXECUTING: editor.unfold for ${l.length} positions`),p.selections=l.map(t=>new i.Selection(t,t)),await i.commands.executeCommand("editor.unfold"),e.appendLine("- COMPLETED: editor.unfold"))}else if(s.length>0){e.appendLine("- No '@collapse' pragma found. Checking for 'alwaysFold' patterns."),e.appendLine("- Parsing document with AST to find function calls...");const l=N(r.getText(),s);if(e.appendLine(`- Found ${l.length} multi-line function calls`),l.length===0)e.appendLine("- No multi-line function calls found to fold");else{for(const o of l){const h=c[o.startLine].trim();e.appendLine(`  - ${o.pattern} at lines ${o.startLine+1}-${o.endLine+1}: ${h.substring(0,50)}...`)}e.appendLine(`- Will fold ${l.length} function calls`);const t=r.uri.toString();T.has(t)||T.set(t,new Set);const m=T.get(t),w=p.visibleRanges,u=new Set;for(const o of l)if(o.endLine>o.startLine){const h=o.startLine+1;!w.some(S=>S.start.line<=h&&S.end.line>=h)&&u.add(o.startLine)}let b=0,A=0,F=0;for(const o of l)try{if(!g&&m.has(o.startLine)){e.appendLine(`  - Skipped ${o.pattern} at line ${o.startLine+1}: manually unfolded by user`),A++;continue}if(!g&&u.has(o.startLine)){e.appendLine(`  - Skipped ${o.pattern} at line ${o.startLine+1}: already folded`),F++;continue}p.selection=new i.Selection(o.startLine,0,o.startLine,0),await i.commands.executeCommand("editor.fold"),b++,m.delete(o.startLine),await new Promise(h=>setTimeout(h,10))}catch(h){e.appendLine(`  - Failed to fold ${o.pattern} at line ${o.startLine+1}: ${h.message}`)}p.selections=f,e.appendLine(`- Folding completed: ${b} folded, ${F} already folded, ${A} manually unfolded`)}}else e.appendLine("- No folding rules to apply (no pragma and alwaysFold is empty)");f&&f.length>0&&(p.selections=f),y=!1,e.appendLine(`- isProcessing reset to: ${y}`),e.appendLine(`=== ANALYZE END ===
`)}function j(){v&&clearTimeout(v)}module.exports={activate:D,deactivate:j};
