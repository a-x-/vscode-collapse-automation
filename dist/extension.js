"use strict";const i=require("vscode"),{parse:x}=require("@typescript-eslint/typescript-estree");let e,g=null,u=!1;function A(o,L){const r=[];try{let l=function(n){if(!(!n||typeof n!="object")){if(n.type==="CallExpression"&&n.callee&&n.loc&&n.callee.type==="MemberExpression"&&n.callee.object&&n.callee.property)for(const t of L){if(!t.includes("."))continue;const[f,v]=t.split(".");if(n.callee.object.type==="Identifier"&&n.callee.object.name===f&&n.callee.property.type==="Identifier"&&n.callee.property.name===v){const C=n.loc.start.line-1,d=n.loc.end.line-1;C!==d&&r.push({pattern:t,startLine:C,endLine:d})}}for(const t in n)if(t!=="parent"&&n[t])if(Array.isArray(n[t]))for(const f of n[t])l(f);else typeof n[t]=="object"&&l(n[t])}};const c=x(o,{ecmaVersion:"latest",sourceType:"module",jsx:!0,errorOnUnknownASTType:!1,range:!0,loc:!0});l(c)}catch(c){e.appendLine(`- ERROR parsing document for AST: ${c.message}`)}return r}function b(o){e=i.window.createOutputChannel("Collapse Automation"),e.appendLine('Extension "collapse-automation" is now active.');const L=t=>{t&&(g&&clearTimeout(g),g=setTimeout(()=>{y(t)},500))},r=i.workspace.onDidChangeTextDocument(t=>{u||L(t.document)}),c=i.workspace.onDidOpenTextDocument(t=>{y(t)}),l=i.window.onDidChangeActiveTextEditor(t=>{t&&y(t.document)}),n=i.commands.registerCommand("collapse-automation.activate",()=>{i.window.activeTextEditor?(g&&clearTimeout(g),y(i.window.activeTextEditor.document)):i.window.showInformationMessage("No active editor found")});o.subscriptions.push(r,c,l,n),i.window.activeTextEditor&&L(i.window.activeTextEditor.document)}async function y(o){if(o.uri.scheme==="output"||o.uri.fsPath.includes("extension-output")||o.uri.fsPath.includes("Collapse Automation")||!["javascript","javascriptreact","typescript","typescriptreact"].includes(o.languageId))return;const r=i.window.activeTextEditor;if(!r||r.document!==o){e.appendLine("- No active editor for this document, skipping");return}e.appendLine(`
=== ANALYZE START at ${new Date().toISOString()} ===`),e.appendLine(`Document: ${o.uri.fsPath}`),e.appendLine(`isProcessing was: ${u}`),u=!0,e.appendLine(`isProcessing now: ${u}`);const c=i.workspace.getConfiguration("collapse-automation"),l=c.get("alwaysFold",[]),n=c.get("neverFold",[]),t=c.get("collapseLevel",1),f=c.get("enableCollapsePragma",!0);if(e.appendLine(`- Config: alwaysFold: [${l.join(", ")}] (length: ${l.length})`),e.appendLine(`- Config: neverFold: [${n.join(", ")}] (length: ${n.length})`),e.appendLine(`- Config: collapseLevel: ${t}`),e.appendLine(`- Config: enableCollapsePragma: ${f}`),(!f||l.length===0)&&l.length===0){e.appendLine("- SKIPPING: No active folding rules (alwaysFold is empty and pragma disabled)"),u=!1,e.appendLine(`=== ANALYZE END (skipped) ===
`);return}const d=o.getText().split(`
`);e.appendLine(`- Document has ${d.length} lines`);const E=f&&d.some(s=>s.includes("// @collapse"));if(e.appendLine(`- Has @collapse pragma: ${E}`),E){e.appendLine("- ACTION: Found '@collapse' pragma. Will apply folding rules."),e.appendLine("- EXECUTING: editor.foldAll"),await i.commands.executeCommand("editor.foldAll"),e.appendLine("- COMPLETED: editor.foldAll"),t>0&&(e.appendLine(`- EXECUTING: editor.unfoldLevel${t}`),await i.commands.executeCommand(`editor.unfoldLevel${t}`),e.appendLine(`- COMPLETED: editor.unfoldLevel${t}`));const s=[];if(n.length>0){e.appendLine("- Checking neverFold patterns...");for(let p=0;p<d.length;p++){const w=d[p];for(const h of n)try{if(new RegExp(h).test(w)){e.appendLine(`  - Line ${p+1} matches neverFold pattern '${h}': ${w.substring(0,50)}...`),s.push(new i.Position(p,0));break}}catch(a){e.appendLine(`  - ERROR: Invalid regex pattern '${h}': ${a.message}`)}}}s.length>0&&(e.appendLine(`- EXECUTING: editor.unfold for ${s.length} positions`),r.selections=s.map(p=>new i.Selection(p,p)),await i.commands.executeCommand("editor.unfold"),e.appendLine("- COMPLETED: editor.unfold"))}else if(l.length>0){e.appendLine("- No '@collapse' pragma found. Checking for 'alwaysFold' patterns."),e.appendLine("- Parsing document with AST to find function calls...");const s=A(o.getText(),l);if(e.appendLine(`- Found ${s.length} multi-line function calls`),s.length===0)e.appendLine("- No multi-line function calls found to fold");else{for(const a of s){const m=d[a.startLine].trim();e.appendLine(`  - ${a.pattern} at lines ${a.startLine+1}-${a.endLine+1}: ${m.substring(0,50)}...`)}e.appendLine(`- Will fold ${s.length} function calls`);let p=0,w=0;const h=r.visibleRanges;for(const a of s)try{let m=!1;if(a.endLine>a.startLine){const $=a.startLine+1;m=!h.some(T=>T.start.line<=$&&T.end.line>=$)}m?(e.appendLine(`  - Skipped ${a.pattern} at line ${a.startLine+1}: already folded`),w++):(r.selection=new i.Selection(a.startLine,0,a.startLine,0),await i.commands.executeCommand("editor.fold"),p++,await new Promise($=>setTimeout($,10)))}catch(m){e.appendLine(`  - Failed to fold ${a.pattern} at line ${a.startLine+1}: ${m.message}`)}e.appendLine(`- Folding completed: ${p} folded, ${w} already folded`)}}else e.appendLine("- No folding rules to apply (no pragma and alwaysFold is empty)");u=!1,e.appendLine(`- isProcessing reset to: ${u}`),e.appendLine(`=== ANALYZE END ===
`)}function P(){g&&clearTimeout(g)}module.exports={activate:b,deactivate:P};
